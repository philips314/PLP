# Primer recuperatorio 2024 -> Primer cuatrimestre.  
## Ejercicio 1.  
El siguiente tipo de datos sirve para representar la logica proposicional:  
data Prop = Var String | No Prop | Y Prop Prop | O Prop Prop | Imp Prop Prop  
type Valuacion = String -> Bool  
Por ejemplo:  
Y (Var "P") (No (Imp (Var "Q") (Var "R"))) representa P ∧ ¬(Q ⇒ R)  

### a. Dar el tipo y definir las funciones foldProp y recProp que implementan el esquema de recursion estructural y primitiva para el tipo Prop (se permite el uso de recursión explicita).  
```
asd
```
Donde:  
```
asd
```
### b. Definir la funcion variables :: Prop -> [String].   
Esta funcion devuelve la lista con todas sus variables proposicionales en algun orden, sin repetidos.    
```
asd
```
### c. Definir la funcion evaluar :: Valuacion -> Prop -> Bool.     
Indica si una formula es verdadera o falsa para una valuacion dada.   
```
asd
```
### d. Definir la funcion estaEnFNN :: Prop -> Bool.    
Indica si una formula esta en Forma Normal negada.    
```
asd 
```
## Ejercicio 2.  
Demostracion de propiedades.  
Considerar las siguientes definiciones sobre árboles con informacion en las hojas.  
```
asd
```
### a. Asumiendo Eq a, demostrar:  
`∀t::AIH a. ∀u:: AIH a. mismaEstuctura t u = mismaEstuctura u t`
Para demostrar esta proposicion, hago induccion estructural sobre el AEB. Tiene dos constructores: Hoja y Bin.  
Defino P(x): esPreRama x xs ⇒ length xs ≤ altura x.  
Caso base: `P(Hoja h)`  
```
asd
```
Paso inductivo: P(Bin i r d).  
Asumo que: `∀i,d::AEB a. P(i) ∧ P(d)` vale {HI}.  
Qvq: `(∀i,d::AEB a. P(i) ∧ P(d)) ⇒ (∀r::a. P(Bin i r d))`, es decir que P(Bin i r d) es mi TI.  
```
asd
```
### b. Usar el algoritmo W para inferir juicios de tipado validos.    
(λx.x(λx.Succ(x)))(λx.x)  
```
asd
```
λx.if isZero(x) then x else x zero
```
asd
```
## Ejercicio 3.  
Se desea modelar Árboles con informacion, para eso se extienden los tipos y expresiones de la siguiente manera:  
τ ::= . . . | AIH(τ)  
M ::= . . . | Hoja(M) | Bin(M,M) | case M of Hoja x ->> M; Bin(i,d) ->> M
* AIH(τ) es el tipo de los arboles con informacion en las hojas de tipo τ.  
* Hoja(M) es un arbol compuesto por una unica hoja con informacion M.
* Bin(M1,M2) es una arbol compuesto por dos subarboles M1 y M2.  
* El obs case M of Hoja x ->> M1; Bin(i,d) ->> M2 permite acceder al valor de un árbol que es hoja
  (el cual se ligará a la variable x que puede aparecer libre en M2), y a los dos subárboles de un arbol que no es hoja (los cuales se ligarán a las variables i y d que pueden aparecer libres en M3)
### a. Introducir las reglas de tipado para la extensión propuesta.  
```
-------------------------- axVacio
Γ ⊢ Vacio_{σ,τ}: Dicc(σ,τ)

Γ ⊢ M: Dicc(σ,τ)    Γ ⊢ N:σ     Γ ⊢ O:τ
------------------------------------------ definir
Γ ⊢ definir(M,N,O): Dicc(σ,τ)

Γ ⊢ M: Dicc(σ,τ)    Γ ⊢ N:σ
-------------------------------- def?
Γ ⊢ def?(M,N): Bool

Γ ⊢ M: Dicc(σ,τ)    Γ ⊢ N:σ
-------------------------------- obtener
Γ ⊢ obtener(M,N): τ
```
### b. Definir el conjunto de valores y las nuevas reglas de semántica operacional a pequeños pasos (congruencia y computo).   
```
asd
```
### c. Mostrar paso por paso como reduce la expresión:  
case(λn: Nat. Hoja(n)) Succ(zero) of Hoja x ->> Succ(Pred(x)); Bin(i,d) ->> zero
```
asd
```
### d. Definir como macro:  
La funcion $esHoja_{τ}$, que toma un AIH(τ) y devuelve un booleano que indica si es una hoja.  
```
asd
```
