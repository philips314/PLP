# Primer recuperatorio 2024 -> Primer cuatrimestre.  
## Ejercicio 1.  
El siguiente tipo de datos sirve para representar la logica proposicional:  
data Prop = Var String | No Prop | Y Prop Prop | O Prop Prop | Imp Prop Prop  
type Valuacion = String -> Bool  
Por ejemplo:  
Y (Var "P") (No (Imp (Var "Q") (Var "R"))) representa P ∧ ¬(Q ⇒ R)  

### a. Dar el tipo y definir las funciones foldProp y recProp que implementan el esquema de recursion estructural y primitiva para el tipo Prop (se permite el uso de recursión explicita).  
```
foldProp fvar _ _ _ _ (Var s) = fvar s
foldProp fvar fnot fy fo fimp (prop) = case prop of
          (No p) = fnot (rec p)
          (Y p1 p2) = fy (rec p1) (rec p2)
          (O p1 p2) = fo (rec p1) (rec p2)
          (Imp p1 p2) = fimp (rec p1) (rec p2)
              where rec = foldProp fvar fnot fy fo fimp
          
```
Donde:  
```
asd
```
### b. Definir la funcion variables :: Prop -> [String].   
Esta funcion devuelve la lista con todas sus variables proposicionales en algun orden, sin repetidos.    
```
asd
```
### c. Definir la funcion evaluar :: Valuacion -> Prop -> Bool.     
Indica si una formula es verdadera o falsa para una valuacion dada.   
```
asd
```
### d. Definir la funcion estaEnFNN :: Prop -> Bool.    
Indica si una formula esta en Forma Normal negada.    
```
asd 
```
## Ejercicio 2.  
Demostracion de propiedades.  
Considerar las siguientes definiciones sobre árboles con informacion en las hojas.  
```
data AIH a = Hoja a | Bin (AIH a) (AIH a)

{E0} esHoja (Hoja x) = True
{E1} esHoja (Bin i d) = False

{I} izq (Bin i d) = i

{D} der (Bin i d) = d

{M0} mismaEstructura (Hoja x) = esHoja
{M1} mismaEstructura (Bin i d) = \t -> not (esHoja t) && mismaEstructura i (izq t) && mismaEstructura d (der t)
```
### a. Demostrar:  
`∀t::AIH a. ∀u:: AIH a. mismaEstuctura t u = mismaEstuctura u t`
### b. Usar el algoritmo W para inferir juicios de tipado validos.    
(λx.x(λx.Succ(x)))(λx.x)  
```
asd
```
λx.if isZero(x) then x else x zero
```
asd
```
## Ejercicio 3.  
Se desea modelar Árboles con informacion, para eso se extienden los tipos y expresiones de la siguiente manera:  
τ ::= . . . | AIH(τ)  
M ::= . . . | Hoja(M) | Bin(M,M) | case M of Hoja x ->> M; Bin(i,d) ->> M
* AIH(τ) es el tipo de los arboles con informacion en las hojas de tipo τ.  
* Hoja(M) es un arbol compuesto por una unica hoja con informacion M.
* Bin(M1,M2) es una arbol compuesto por dos subarboles M1 y M2.  
* El obs case M of Hoja x ->> M1; Bin(i,d) ->> M2 permite acceder al valor de un árbol que es hoja
  (el cual se ligará a la variable x que puede aparecer libre en M2), y a los dos subárboles de un arbol que no es hoja (los cuales se ligarán a las variables i y d que pueden aparecer libres en M3)
### a. Introducir las reglas de tipado para la extensión propuesta.  
```
asd
```
### b. Definir el conjunto de valores y las nuevas reglas de semántica operacional a pequeños pasos (congruencia y computo).   
```
asd
```
### c. Mostrar paso por paso como reduce la expresión:  
case(λn: Nat. Hoja(n)) Succ(zero) of Hoja x ->> Succ(Pred(x)); Bin(i,d) ->> zero
```
asd
```
### d. Definir como macro:  
La funcion $esHoja_{τ}$, que toma un AIH(τ) y devuelve un booleano que indica si es una hoja.  
```
asd
```
